
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://ilyapavlovskii.github.io/IlyaPavlovskii/android/russian/stop-refactoring/">
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>Стоп рефакторинг. Kotlin. Android - Ilia Pavlovskii</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.1d29e8d0.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#kotlin-android" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Ilia Pavlovskii" class="md-header__button md-logo" aria-label="Ilia Pavlovskii" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Ilia Pavlovskii
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Стоп рефакторинг. Kotlin. Android
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Ilia Pavlovskii" class="md-nav__button md-logo" aria-label="Ilia Pavlovskii" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Ilia Pavlovskii
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Introduction
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          Android
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Android" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Android
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_1" type="checkbox" id="__nav_2_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_2_1">
          Russian
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Russian" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          Russian
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Стоп рефакторинг. Kotlin. Android
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Стоп рефакторинг. Kotlin. Android
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    Введение
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-else-when" class="md-nav__link">
    Заменяйте if-else на when где это необходимо
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Отряд булевых флажков
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Одно состояние
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    Абстракции - не лишнее
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Описывайте состояния явно
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#when" class="md-nav__link">
    When может не хватить
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Наследование или композиция
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    Уменьшение области видимости
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    Заключение
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          Other
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Other" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          Other
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../other/pbh/" class="md-nav__link">
        Год в Польше по PBH
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="https://www.linkedin.com/in/ipavlovskii/" class="md-nav__link">
        LinkedIn
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/IlyaPavlovskii/" class="md-nav__link">
        GitHub
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="https://habr.com/ru/users/TranE91/posts/" class="md-nav__link">
        Habr
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="https://pavlovskiiilia.medium.com/" class="md-nav__link">
        Medium
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    Введение
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-else-when" class="md-nav__link">
    Заменяйте if-else на when где это необходимо
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Отряд булевых флажков
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Одно состояние
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    Абстракции - не лишнее
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Описывайте состояния явно
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#when" class="md-nav__link">
    When может не хватить
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Наследование или композиция
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    Уменьшение области видимости
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    Заключение
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


<h1 id="kotlin-android">Стоп рефакторинг. Kotlin. Android</h1>
<h3 id="_1">Введение</h3>
<p align="center">
  <img src="resources/header.png" />
</p>
<p>Работая над одним проектом продолжительное время, я заметил как приходится переписывать код, который еще три месяца
назад казался хорошим. Инженерам поступают новые требования, когда они не пересекаются с предыдущими - все отлично,
добавили пару новых классов и побежали дальше. Иногда они касаются уже выпущенной части - взмах синей изолентой и все
работает. Но наступает тот самый момент, когда цена внесения изменений катастрофически дорога и единственное
рациональное решение - переписать все... А можно ли писать код, не переписывая его в будущем или хотя бы отложить этот
момент на более долгий срок?</p>
<p>Я хочу рассказать про практики, которые не один раз уже выручали нас в проекте. Подборка примеров получилась не на
пустом месте, все реальные примеры PullRequest-ов.Все примеры НЕ выдуманные и тестировались на живых людях. В процессе
сбора данных несколько людей пострадало.</p>
<h3 id="if-else-when">Заменяйте if-else на when где это необходимо</h3>
<p>Долгое время Java был предпочтительным языком программирования для платформы Android. Затем на арену пришел Kotlin, да
вот привычки остались старые.</p>
<pre><code class="language-kotlin">fun getNumberSign(num: Int): String = if (num &lt; 0) {
    &quot;negative&quot;
} else if (num &gt; 0) {
    &quot;positive&quot;
} else {
    &quot;zero&quot;
}
</code></pre>
<p>Красиво - 7 строк и получаем результат. Можно проще:</p>
<pre><code class="language-kotlin">fun getNumberSign(num: Int): String = when {
    num &lt; 0 -&gt; &quot;negative&quot;
    num &gt; 0 -&gt; &quot;positive&quot;
    else -&gt; &quot;zero&quot;
}
</code></pre>
<p>Тот же код, а строк 5.</p>
<p>Не забываем и про каскадное использование <code>if-else</code> и его нечитабильность при разрастании кодобазы.
Если в вашем проекте нет необходимости поддерживать 2 ЯП(Kotlin + Java), настоятельно рекомендую взять его себе на
вооружение. Одна из самых популярных причин его игнорирования - "Не привычно…"</p>
<p align="center">
  <img src="resources/it-used-to-be-better.png" />
</p>

<p>Дело не в предпочтениях стилистики писания: семистопный дактиль или пятистопный хорей. Дело в том, что в Kotlin
отсутствует оператор<code>else-if</code>. Упуская этот момент можно выстрелить себе в ногу. А вот и сам пазлер №9 от
<a href="https://habr.com/ru/company/jugru/blog/338924/">Антона Кекса</a>.</p>
<p>Я не рекомендую использовать<code>when</code>везде, где только можно. В Kotlin нет
(<a href="https://discuss.kotlinlang.org/t/announcement-about-closing-two-topics-and-a-code-of-conduct-reminder/9160">и не будет</a>)
тернарного оператора, и стандартные булевы условия стоит использовать по классике. Когда условий больше двух,
присмотритесь и сделайте код элегантнее.</p>
<h3 id="_2">Отряд булевых флажков</h3>
<p>Рассмотрим следующее на примере поступающего ТЗ в динамике:</p>
<blockquote>
<ol>
<li>Пользователь должен иметь возможность видеть доставлено сообщение или нет</li>
</ol>
</blockquote>
<pre><code class="language-kotlin">data class Message(
  // ...
  val isDelivered: Boolean
)
</code></pre>
<p>Все ли здесь хорошо? Будет ли модель устойчива к изменениям? Есть ли гипотетическая возможность того, что в модели
типа<code>Message</code>не будут добавлены новые условия в будущем? Имеем ли мы право считать, что исходные условия ТЗ есть
оконченный постулат, который нельзя нарушить?</p>
<p align="center">
  <img src="resources/two-hours-later.png" />
</p>

<blockquote>
<ol>
<li>Пользователь должен иметь возможность видеть прочитано сообщение или нет</li>
</ol>
</blockquote>
<pre><code class="language-kotlin">data class Message(
  // ...
  val isDelivered: Boolean,
  val isRead: Boolean
) 
</code></pre>
<p>Не успели мы моргнуть глазом, как ProductOwner передумал и внес изменения в первоначальные условия. Неожиданно? Самое
простое решение - добавить новое поле и "решить" проблему. Огорчу, не решить - отложить неизбежное. Избавление от
проблемы здесь и сейчас - must have каждого IT инженера. Предсказание изменений и делать устойчивую систему - опыт,
паттерны, а иногда, искусство.</p>
<p>Под "отложить неизбежное" я подразумеваю факт того, что рано или поздно система станет неустойчива и придет время
рефакторинга. Рефакторинг -&gt; дополнительное время на разработку -&gt; затраты не по смете бюджета -&gt; неудовлетворенность
заказчика -&gt; увольнение -&gt; депрессия -&gt; невозможность решить финансовый вопрос -&gt; голод -&gt; смерть. Все из-за Boolean
флага?!!! COVID-19 не так уж страшен.</p>
<p>Что не так? Сам факт появления изменений не есть глупость PO, который не мог сразу сформулировать свою мысль. Не все то,
что очевидно сейчас, было очевидно ранее. Чем меньше время на маневр, тем вы ценнее и конкурентнее. Далее включим
фантазию и попробуем предугадать, что же еще может придумать менеджер?</p>
<blockquote>
<ol>
<li>Пользователь должен иметь возможность видеть отправлено ли сообщение</li>
<li>Пользователь должен иметь возможность видеть появилось ли сообщение в нотификациях e.t.c.</li>
</ol>
</blockquote>
<p>Если мы сложим воедино все новые требования, будет видно, что объект<code>Message</code>может находиться только в одном состоянии:
отправлено, доставлено, появилось ли сообщение в нотификациях, прочитано… Набор состояний`детерминирован. Опишем их и
заложим в наш объект:</p>
<pre><code class="language-kotlin">data class Message(
  // ...
  val state: State
) {
    enum class State {
        SENT,
        DELIVERED,
        SHOWN_IN_NOTIFICATION,
        READ
    }
}
</code></pre>
<p>Набор определен. Мы однозначно можем считать, что если сообщение прочитано, то оно отправлено и доставлено… Для этого мы
можем полагаться на приоритет состояний, забегу вперед, лучше всего переопредлить компаратор, где приоритет будет указан
явно. Но можем ли мы утверждать, что оно отображалось в нотификациях? Ведь пользователь может отключить системный показ
нотификаций. В случае, когда это будет действительно важно, однозначное состояние не подойдет. В таком случае, мы можем
воспользоваться бинарными флагами:</p>
<pre><code class="language-kotlin">data class Message(
  // ...
  val states: Set&lt;State&gt;
) {
  fun hasState(state: State): Boolean = states.contains(state)
}
// либо 
data class Message(
    // ...
    val states: States
) {
    enum class State(internal val flag: Int) {
        SENT(1),
        DELIVERED(1 shl 1),
        READ(1 shl 2),
        SHOWN_IN_NOTIFICATION(1 shl 3)
    }

    data class States internal constructor(internal val flags: Int) {
        init {
          check(flags and (flags+1)) { &quot;Expected value: flags=2^n-1&quot; }
        }
        constructor(vararg states: State): this(
            states.map(State::flag).reduce { acc, flag -&gt; acc or flag }
        )

        fun hasState(state: State): Boolean = (flags and state.flag) == state.flag
    }
}
</code></pre>
<p>Выводы: перед тем как начать проектировать систему, задайте необходимые вопросы, которые помогут вам найти подходящее
решение. <em>Можно ли считать набор условий конечным? Не изменится ли он в будущем?</em> Если ответы на эти вопросы ДА-ДА - смело
вставляйте булево состояние. Если же хоть на один вопрос ответ НЕТ - заложите детерменированный набор состояний. Если
объект в один момент времени может находиться в нескольких состояниях - закладывайте множество.</p>
<p>А теперь посмотрим на решение с булевыми флагами:</p>
<pre><code class="language-kotlin">data class Message(
  //..
  val isSent: Boolean,
  val isDelivered: Boolean
  val isRead: Boolean,
  val isShownInNotification: Boolean
) 
//...
fun drawStatusIcon(message: Message) {
  when {
    message.isSent &amp;&amp; message.isDelivered &amp;&amp; message.isRead &amp;&amp; message.isShownInNotification -&gt; 
        drawNotificationStatusIcon()
    message.isSent &amp;&amp; message.isDelivered &amp;&amp; message.isRead -&gt; drawReadStatusIcon()
    message.isSent &amp;&amp; message.isDelivered -&gt; drawDeliviredStatusIcon()
    else -&gt; drawSentStatus() 
  }
}
</code></pre>
<p>Попробуйте добавить еще одно состояние(ошибку) в конец и в середину списка приоритетов. Без чтения документации и без
ознакомления работы с флагами это сделать будет проблематично.</p>
<h3 id="_3">Одно состояние</h3>
<p>Одно состояние описывается несколькими независимыми переменными. Редкая проблема, которая открывается при потере фокуса
над контекстом разрабатываемого компонента.</p>
<pre><code class="language-kotlin">data class User(
    val username: String?
    val hasUsername: Boolean
)
</code></pre>
<p>По условию контракта есть возможность не заполнить имя пользователя. На GUIне такое состояние должно подсветиться
предложением. За состояние предложения, логично считать, переменную`hasUsername. По объявленным соглашениям, легко
допустить простую ошибку.</p>
<pre><code class="language-kotlin">// OK
val user1 = User(username = null, hasUsername = false) 
// Ошибка, имя пользователя есть
val user2 = User(username = &quot;user&quot;, hasUsername = false) 
// OK
val user3 = User(username = &quot;user&quot;, hasUsername = true) 
// Ошибка, имя пользователя не задано, а флаг говорит об обратном
val user4 = User(username = null, hasUsername = true) 
// Ошибка, имя пользователя пустое, а флаг говорит об обратном
val user5 = User(username = &quot;&quot;, hasUsername = true) 
// Ошибка, имя пользователя пустое, а флаг говорит об обратном
val user6 = User(username = &quot; &quot;, hasUsername = true) 
</code></pre>
<p>Узкие места в контракте открывают двери для совершения ошибки. Источником ответственности за наличие имени является
только одно поле -<code>username</code>.</p>
<pre><code class="language-kotlin">data class User(
    val username: String?
) {
    fun hasUsername(): Boolean = !username.isNullOrBlank()
}
</code></pre>
<p>Когда состояние может быть калькулируемым - вычисляйте его по требованию. Не стоит дублировать понятия, очень просто
выстрелить себе в ногу на ровном месте. Исключением могут быть случаи, когда операция вычисления занимает длительное
время либо требует кэширование состояния. В таких ситуациях можно воспользоваться иными практиками для определения
статуса:</p>
<ul>
<li>вычислить сразу либо заленивить состояние</li>
</ul>
<pre><code class="language-kotlin">data class User(
    val username: String?
) {
    val hasUsername: Boolean = !username.isNullOrBlank()
    val hasUsernameLazy: Boolean by lazy { !username.isNullOrBlank() }
}
</code></pre>
<ul>
<li>вынести вычисление в утилитарный класс. Используйте только в случае тяжеловесности операции</li>
</ul>
<pre><code class="language-kotlin">class UsernameHelper {
    private val cache: MutableMap&lt;User, Boolean&gt; = WeakHashMap()

    fun hasUsername(user: User): Boolean = cache.getOrPut(user) { 
      !user.username.isNullOrBlank() 
    }
}
</code></pre>
<h3 id="-">Абстракции - не лишнее</h3>
<p>Я часто наблюдаю, как разработчики отказываются от абстракций. К нам поступает описание задачи, инженер приходит к
выводу, что его решение будет оптимально и… прибивает гвоздями решение к компоненту. Спустя время приходим к выводу, что
решение стоит заменить, и не остается ничего, кроме как влезать в каждый компонент и решать проблему индивидуально.</p>
<blockquote>
<p>Ключи для 3rd party services получаем из backend. Клиент должен<code>сохранить</code>эти ключи для дальнейшего использования в
приложении.</p>
</blockquote>
<pre><code class="language-kotlin">// ...
val result = remoteService.getConfig()
if (result is Result.Success) {
  val remoteConfig = result.value.clientConfig?.keys
  for (localConfigKey: ConfigKey in configKeyProvider.getConfigKeys()) {
      sharedPreferences.edit { putString(localConfigKey.key, remoteConfig[localConfigKey.key]) }  
  }
}
//...
enum class ConfigKey(val key) {
  FACEBOOK(&quot;facebook&quot;),
  MAPBOX(&quot;mapbox&quot;),
  THIRD_PARTY(&quot;some_service&quot;)
}
</code></pre>
<p>Спустя N недель получаем предупреждение от службы безопасности, что ключи сервиса<code>THIRD_PARTY</code>ни в коем случае нельзя
хранить на диске устройства. Не страшно, можем спокойно хранить ключи хранить InMemory. И по такой же стратегии нужно
затронуть еще 20 компонентов приложения. Хм, и как поможет абстракция?</p>
<p align="center">
  <img src="resources/its-easy.png" />
</p>

<p>Завернем под абстракцию хранлище ключей и создадим имплементацию: InMemory / SharedPreferences / Database /
WeakInMemory… А дальше с помощью внедрения зависимостей. Таким образом мы не нарушим <strong>SO</strong>LID - в нашем примере актором
будет являться алгоритм сбора данных, но не способ хранения; open-closed principle достигается тем, что мы "прикрываем"
необходимость модификации алгоритма за счет абстракции.</p>
<pre><code class="language-kotlin">// ...
val result = remoteService.getConfig()
if (result is Result.Success) {
  val remoteConfig = result.value.clientConfig?.keys
  for(localConfigKey: ConfigKey in configKeyProvider.getConfigKeys()) {
        configurationStorage.put(
        configKey = localConfigKey, 
        keyValue = remoteConfig[localConfigKey.key]
      )
  }
}
//....
interface ConfigKeyStorage {
   fun put(configKey: ConfigKey, keyValue: String?)
   fun get(configKey: ConfigKey): String
   fun getOrNull(configKey: ConfigKey): String?
}

internal class InMemoryConfigKeyStorage : ConfigKeyStorage {
    private val storageMap: MutableMap&lt;ConfigKey, String?&gt; = mutableMapOf()

  override fun put(configKey: ConfigKey, keyValue: String?) {
    storageMap[configKey] = keyValue
    }

    override fun get(configKey: ConfigKey): String = 
      requireNotNull(storageMap[configKey])
    override fun getOrNull(configKey: ConfigKey): String? = 
      storageMap[configKey]
}
</code></pre>
<p>Если помните, в изначальной постановке задачи не стояло уточнение о типе хранилища данных. Подготавливаем систему к
изменениям, где имплементация может быть различной и никак не влияет на детали алгоритма сбора данных. Даже если в
изначальных требованиях и были бы уточнения по типу хранилища - это повод для того, чтобы усомниться и перестраховаться.
Вместо того, чтобы влезать в N компонентов для модификации типа хранилища, можно добиться этого с помощью замены
источника данных через DI/IoC и быть уверенным, что все работает исправно. Так же, такой код проще тестировать.</p>
<h3 id="_4">Описывайте состояния явно</h3>
<p>Программисты ленивые люди. Я нахожу в этом свои плюсы, что такая профессиональная деформация позволяет делать
расслабленные решения которые будут понятны каждому(в любом состоянии). Часто, самое простое и быстрое решение задачи -
правильное решение. Но вот воспринимать это слишком буквально не стоит. Не смотреть в завтрашний день чревато тем, что
через неделю ты будешь стахановцем без привычного смузи.</p>
<p align="center">
  <img src="resources/kiss.png" />
</p>

<p>В очередной раз возьмем пример технического задания:</p>
<blockquote>
<p>Подготовить репозиторий для вывода имени пользователя на экран</p>
</blockquote>
<p>Создадим репозиторий, который будет возвращать имя пользователя. Выведем<code>null</code>в случае, если не смогли получить имя. Так
как в первоначальном задании не шло речи о том, откуда нам нужно брать данные - оставим дело за абстракцией и заодно
создадим наивное решение для получения из remote.</p>
<pre><code class="language-kotlin">interface UsernameRepository {
    suspend fun getUsername(): String?
}
class RemoteUsernameRepository(
    private val remoteAPI: RemoteAPI
) : UsernameRepository {
    override suspend fun getUsername(): String? = try {
        remoteAPI.getUsername()
    } catch (throwable: Throwable) {
        null
    }
}
</code></pre>
<p>Мы создали контракт получения имени пользователя, где в качестве успeшного результата приходит состояние<code>String?</code>и в
случае провала
получения<code>String?</code>. При чтении кода, нет ничего подозрительного. Мы можем определить состояние ошибки простым условием<code>getUsername() == null</code>и все будут счастливы. По факту, мы не имеем состояния провала. По контракту <code>SuccessState ===
FailState</code>.</p>
<blockquote>
<p>Подготовить репозиторий для вывода имени пользователя на экран. В случае ошибки получения данных из удаленного узла,
вывести последнее известное.</p>
</blockquote>
<p>После уточнения тех задания, мы должны сделать развилку. Распишем развилку абстрактно и подсветим проблемное место:</p>
<pre><code class="language-kotlin">interface UsernameRepository {
    suspend fun getUsername(): String?
}
class CommonUsernameRepository(
  private val remoteRepository: UsernameRepository,
  private val localRepository: UsernameRepository
) : UsernameRepository {
    suspend fun getUsername(): String? {
        return remoteRepository.getUsername() ?: localRepository.getUsername()
    }
}
</code></pre>
<p>И вот наступает грустный момент. Теперь по нашему контракту 3 различных состояния при одном и том же результате.
Попробуйте ответить на следующие утверждения:</p>
<ul>
<li>
<p>верно ли утверждать, что результат <code>null</code> - имя пользователя? Обязательных условий мы не имеем. Все легально.</p>
</li>
<li>
<p>верно ли утверждать, что результат <code>null</code> - состояние из кэша?</p>
</li>
<li>
<p>верно ли утверждать, что результат <code>null</code> - состояние ошибки удаленного узла при пустом кэше?</p>
</li>
</ul>
<p>Однозначного ответа нет, так как наш контракт не подразумевает этого. Да и по требованиям от нас этого не требуют. А
зачем нужно явно декларировать состояния для системы, если важен результат? Смежные состояния при одинаковых
результатах - русло неустойчивости узла к изменениям. Избегайте неоднозначности. Новые требования, которые затронут хотя бы один
смежный статус, потребуют рефакторинга корневой модели. Изменения в начальной абстракции - это очень страшно. 
Это чревато тем, что вам придется переписать все известные имплементации.</p>
<blockquote>
<p>В случае получения ошибки - изменить цвет имени на экране.</p>
</blockquote>
<p>Используйте<code>enum/sealed classes/interfaces/abstract classes</code>. Техника выведения абстракций зависит от изначальных 
условий проекта. Если вам важна строгость в контрактах и вы хотите закрыть возможность произвольного
расширения -<code>enum/sealed classes</code>. В противном случае -<code>interface/abstract classes</code>.</p>
<pre><code class="language-kotlin">sealed class UsernameState {
    data class Success(val username: CharSequence?) : UsernameState()
  object Failed : UsernameState()
}
</code></pre>
<h3 id="when">When может не хватить</h3>
<p>Рассмотрим следующий пример - старт приложения, где в зависимости от состояния приложения необходимо выполнить переход
на следующий экран.</p>
<p align="center">
  <img src="resources/block-scheme.png" />
</p>

<pre><code class="language-kotlin">enum class NavigationFlow {
  PIN_CODE,
  MAIN_SCREEN,
  ONBOARDING,
  CHOOSE_LANGUAGE
}
fun detectNavigationFlow(): NavigationFlow {
    return when {
        authRepo.isAuthorized() -&gt; NavigationFlow.PIN_CODE
        languageRepo.defaultLanguage != null -&gt; NavigationFlow.CHOOSE_LANGUAGE
        onboardingStorage.isCompleted() -&gt; NavigationFlow.MAIN_SCREEN
        else -&gt; NavigationFlow.ONBOARDING
    }
}
</code></pre>
<p>Мы определили возможные состояния навигации. Так проще будет реализовать навигатор. Но вот <code>detectNavigationFlow</code> стал
слишком много знать. Разломать функцию могут следующие события: добавить новое состояние, изменить приоритет или когда
используемый репозиторий станет устаревшим… Постараемся создать такую функцию, в которой основной участок будет
неизменен, а шаги можно будет легко заменить.</p>
<pre><code class="language-kotlin">enum class NavigationFlow {
    PIN_CODE,
    MAIN_SCREEN,
    ONBOARDING,
    CHOOSE_LANGUAGE
}

// Описываем возможные состояния явно
sealed class State {
    data class Found(val flow: NavigationFlow) : State()
    object NotFound : State()
}

interface NavigationFlowProvider {
    // Возвращаем не null NavigationFlow чтобы гарантировать проход на следующий экран
    fun getNavigation(): NavigationFlow
}

// Абстракция для поиска подходящего флоу для навигации
interface NavigationFlowResolver {
    fun resolveNavigation(): State
}

internal class SplashScreenNavigationFlowProvider(
    // Sequence - для того чтобы прервать итерации при нахождении первого подходящего условия.
    // Обратите внимание на очередность экземляров класса в последовательности.
    private val resolvers: Sequence&lt;NavigationFlowResolver&gt;
) : NavigationFlowProvider {

    override fun getNavigation(): NavigationFlow = resolvers
        .map(NavigationFlowResolver::resolveNavigation)
        .filterIsInstance&lt;State.Found&gt;()
        .firstOrNull()?.flow
        // Если ничего не нашли - проход в состояние неизвестности
        ?: NavigationFlow.MAIN_SCREEN
}
</code></pre>
<p>Заменяем N-условный <code>when</code> на <a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">ChainOfResponsibililty</a>.
На первый взгляд выглядит сложным: кода стало больше и алгоритм чуть сложнее. Перечислим плюсы подхода:</p>
<blockquote>
<ol>
<li>Знакомый паттерн из ООП</li>
<li>Соответствует правилам SOLID</li>
<li>Прост в масштабировании</li>
<li>Прост в тестировании</li>
<li>Компоненты резолвера независимы, что никак не повлияет на структуру разработки</li>
</ol>
</blockquote>
<p>Главное в таком подходе - масштабируемость и независимость компонентов. Нам позволено сколь угодно наращивать систему не
боясь за общую обработку. Каждый элемент резолвера заменим в любой момент. Новый компонент легко вставить в
последовательность, нужно только следить за очередностью вызова. Независимые компоненты упрощают жизнь в динамике. С
помощью <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">DIP</a> каждому компоненту системы доступно быть 
сколь угодно сложным, что никак не скажется на общем алгоритме.</p>
<h3 id="_5">Наследование или композиция</h3>
<p>Вопрос по этой теме поднимался ни один миллион`раз. Я не буду останавливаться на подробностях, детали о проблемах можете
почитать на просторах google. Хочу затронуть тему платформы, когда причина избыточного использования наследования - "
платформа". Разберем на примерах компонентов Android.</p>
<p><strong>BaseActivity</strong>. Заглядывая в старые прокты, с ужасом наблюдаю, какую же ошибку мы допускали. Под маской повторного
использования смело добавляли частные случаи в базовую активити. Шли недели, активити обрастали общими прогрессбарами,
обработчиками и пр. Проходят месяцы, поступают требования - на экране N прогрессбар должен отличаться от того, что на
всех других… От общей активити отказаться уже не можем, слишком много она знает и выполняет. Добавить новый прогрессбар
как частный случай - выход, но в базовом будет оставаться рудимент и это будет нечестное наследование. Добавить вариацию
в<code>BaseActivity</code>- обидеть других наследников и… Через время вы получаете монстра в &gt; 1000 строк, цена внесения изменений
в который слишком велика. Да и не по SOLID это все.</p>
<blockquote>
<p>Агаок, но мне нужно использовать компоненту, которая точно будет на всех экранах кроме 2х. Что делать?</p>
</blockquote>
<p>Не проблема, Android SDK еще с 14 версии 
<a href="https://developer.android.com/reference/android/app/Application#registerActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks)">предоставили такую возможность</a>. 
<code>Application.ActivityLifecycleCallbacks</code> открывает нам простор на то, чтобы переопределять элементы жизненного цикла любой
<code>Activity</code>. Теперь общие случаи можно вынести в обработчик и разгрузить базовый класс.</p>
<pre><code class="language-kotlin">class App : Application(), KoinComponent {
    override fun onCreate() {
        super.onCreate()
        // ... 
        registerActivityLifecycleCallbacks(SetupKoinFragmentFactoryCallbacks())
    }
    // Подключаем Koin FragmentFactory для инициализации фрагментов с помощью Koin
    private class SetupKoinFragmentFactoryCallbacks : EmptyActivityLifecycleCallbacks {
        override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) {
            if (activity is FragmentActivity) {
                activity.setupKoinFragmentFactory()
            }
        }
    }
}
</code></pre>
<p>К сожалению, не всегда возможно отказаться от базовой активити. Но можно сделать ее простой и лаконичной:</p>
<pre><code class="language-kotlin">abstract class BaseActivity(@LayoutRes contentLayoutId: Int = 0) : AppCompatActivity(contentLayoutId) {
    // attachBaseContext по умолчанию protected
    override fun attachBaseContext(newBase: Context) {
        // добавляем extension для изменения языка на лету
        super.attachBaseContext(newBase.applySelectedAppLanguage())
    }
}
</code></pre>
<p><strong>BaseFragment</strong>. С фрагментами все тоже самое. Изучаем <a href="https://developer.android.com/reference/androidx/fragment/app/FragmentManager">FragmentManager</a>, 
добавляем <a href="https://developer.android.com/reference/androidx/fragment/app/FragmentManager.FragmentLifecycleCallbacks">registerFragmentLifecycleCallbacks</a> - 
профит. Чтобы пробросить <code>FragmentLifecycleCallbacks</code> для каждого фрагмента - используйте наработки из предыдущих 
примеров с <code>Activty</code>. Пример на базе Koin - <a href="https://github.com/InsertKoinIO/koin/search?q=KoinFragmentFactory">здесь</a>.</p>
<p>Композиция и фрагменты. Для передачи объектов можем использовать инъекции DIP фреймворков - Dagger, Koin, свое и т.д. А
можем отвязаться от фрейморков и передать их в конструктор. ЧТОООО? Типичный вопрос с собеседования - Почему нельзя
передавать аргументы в конструктор фрагмента? До <a href="https://developer.android.com/jetpack/androidx/releases/fragment#1.1.0-alpha01">5 ноября 2018 года было именно так, теперь же есть</a> 
<code>FragmentFactory</code>и это стало легально.</p>
<p><strong>BaseApplication</strong>. Здесь чуть сложнее. Для разных <code>Flavors</code> и <code>BuildType</code> необходимо использовать базовый 
<code>Application</code> для возможности переопределения компонентов для других сборок. Как правило, <code>Application</code>становится 
большим, потому что на старте приложения, необходимо проинициализировать большое количество 3rd party библиотек. 
Добавим к этому и список своих инициализаций и вот мы на пороге того момента, когда нам нужно разгрузить стартовую 
точку.</p>
<pre><code class="language-kotlin">interface Bootstrapper {
    // KoinComponent - entry point DIP для возможности вызвать инъекции зависимостей в метод 
    fun init(component: KoinComponent)
}
interface BootstrapperProvider {
    fun provide(): Set&lt;Bootstrapper&gt;
}
class BootstrapperLauncher(val provider: BootstrapperProvider) {
    fun launch(component: KoinComponent) {
        provider.provide().onEach { it.init(component) }
    }
}
class App : Application() {
  override fun onCreate() {
        super.onCreate()
        // Вызываем бутстраппер после инициализации Koin
        this.get&lt;BootstrapperLauncher&gt;().launch(component = this)
    }
}
</code></pre>
<p>Разгружаем килотонны методов в разные<code>Bootstrapper</code>инстансы и делаем наш код чище. Либо можем воспользоваться нативным
решением от <a href="https://developer.android.com/topic/libraries/app-startup">зеленого робота</a>.</p>
<h3 id="_6">Уменьшение области видимости</h3>
<p>Инкапсуляция - один из немаловажных моментов в ООП парадигме. Современные языки программирования не просто так содержат
в себе модификаторы доступа, которые ограничивают скоуп видимости сигнатур. Уменьшение простора на использование строк
кода поддержано на уровне компилятора. Это отличная защита от (~~дурака~~)того, что код изначально написан так, чтобы его
нельзя было модифицировать. В противном случае, он не скомпилируется. На практике встречаются случаи, когда ограничения
касаются только внутренних состояний и поведений объекта - приватные функции, а что насчет самого объекта?</p>
<p>Выделим отдельный модуль, который будет содержать в себе объекты валидации входящих состояний.</p>
<pre><code class="language-kotlin">interface Validator {
    fun validate(contact: CharSequence): ValidationResult
}

sealed class ValidationResult {
    object Valid : ValidationResult()

    data class Invalid(@StringRes val errorRes: Int) : ValidationResult()
}

class PhoneNumberValidator : Validator {
    override fun validate(contact: CharSequence): ValidationResult =
        if (REGEX.matches(contact)) ValidationResult.Valid 
        else ValidationResult.Invalid(R.string.error)

    companion object {
        private val REGEX = &quot;[0-9]{16}&quot;.toRegex()
    }
}
</code></pre>
<p>А разве плохо иметь публичный класс, который будет доступен всем? Но избыточное использование публичных сущностей по
умолчанию означает, что объект данного класса может использоваться каждым. Возникает желание внести изменения для личных
нужд не задумываясь о последствиях. Если вы не обезопасились методами, которые не пропустят "сломанный" код в рабочую
среду, ждите бага.</p>
<p>Пришло обновление задачи, когда на экране N вместо <a href="https://ru.wikipedia.org/wiki/MSISDN">MSISDN</a> необходимо 
использовать <a href="https://ru.wikipedia.org/wiki/E.164">E.164</a>:</p>
<p align="center">
  <img src="resources/wat-again.png" />
</p>

<pre><code class="language-kotlin">class PhoneNumberValidator : Validator {
    override fun validate(contact: CharSequence): ValidationResult =
        if (REGEX.matches(contact)) ValidationResult.Valid 
        else ValidationResult.Invalid(R.string.error)

    companion object {
        private val REGEX = &quot;+[0-9]{16}&quot;.toRegex()
    }
}
</code></pre>
<p>Да вот беда, такое наглое вмешательство в дела валидации разломало наше старое поведение на других экранах ввода, так
репозитории не были готовы принять знак плюса в начале строки. Можно было бы обойтись документацией, которая бы
описывала поведение и последствия изменения. Однако, документацию читают не всегда. Она не дает строгости использования.</p>
<p>С одной стороны, проблема надуманная и обойти ее можно было:</p>
<ul>
<li>создать новый валидатор</li>
<li>создать валидатор с регексом по умолчанию и передать аргумент для частного случая</li>
<li>наследование и переопределение</li>
<li>другой подход</li>
</ul>
<p>А теперь, давайте посмотрим на код, если бы мы изначально забетонировали MSISDN валидатор и вынесли бы его в бинарь.</p>
<pre><code class="language-kotlin">interface Validator {
    fun validate(contact: CharSequence): ValidationResult
}

sealed class ValidationResult {
    object Valid : ValidationResult()

    data class Invalid(@StringRes val errorRes: Int) : ValidationResult()
}
internal class MSISDNNumberValidator : Validator {
    //... код выше
}
internal class E164NumberValidator : Validator {
    //... код выше
}
</code></pre>
<p>Как видите, при таком подходе разработчику будет сложно вносить изменения в уже существующий код потому, что он закрыт.
Осталось решить проблему создания валидаторов и возможность их расширения:</p>
<pre><code class="language-kotlin">interface ValidatorFactory {
    fun create(type: ValidatorType): Validator?

    interface ValidatorType

    companion object {
        fun create() : ValidatorFactory {
            return DefaultValidatorFactory()
        }
    }
}
object MSISDN : ValidatorFactory.ValidatorType
object E164 : ValidatorFactory.ValidatorType
private class DefaultValidatorFactory : ValidatorFactory {
    override fun create(type: ValidatorFactory.ValidatorType): Validator? = when(type) {
        is MSISDN -&gt; MSISDNValidator()
        is E164 -&gt; E164Validator()
        else -&gt; null
    }
}
</code></pre>
<p>Собираем кубик, пакуем в бинарь и отдаем в использование. По мере необходимости код открыт для расширения, но закрыт для
модификации. Если вы захотите добавить свою валидацию - смело можете создать<code>ValidatorFactory</code> с фолбэком на 
<code>DefaultValidatorFactory</code>. Или выпустить новый патч.</p>
<h3 id="_7">Заключение</h3>
<p>В общем случае, при проектировании систем, я руководствуюсь правилам SOLID. Про эти принципы говорят не первый десяток
лет из каждого утюга, но они все еще актуальны. Местами система выглядит избыточной. Стоит ли заморачиваться насчет
сложности и стабильности дизайна кода? Решать вам. Однозначного ответа нет. Определиться вы можете в любой момент.
Желательно - на зачаточном этапе. Если вам стало понятно, что ваш проект может жить более чем полгода и он будет расти -
пишите гибкий код. Не обманывайте себя, что это все оверинженерия. Мобильных приложений с 2-3 экранами уже давно нет.
Разработка под мобильные устройства уже давно вошла в разряд enterprise. Быть маневренным - золотой навык. Ваш бизнес не
забуксует на месте и поток запланнированных задач реже станет оставать от графика.</p>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
        
        <a href="../../.." class="md-footer__link md-footer__link--prev" aria-label="Previous: Introduction" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Introduction
            </div>
          </div>
        </a>
      
      
        
        <a href="../../../other/pbh/" class="md-footer__link md-footer__link--next" aria-label="Next: Год в Польше по PBH" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Год в Польше по PBH
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.6c7ad80a.min.js"></script>
      
    
  </body>
</html>